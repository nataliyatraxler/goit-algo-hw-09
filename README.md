Касова система для видачі решти

Це домашнє завдання реалізує два підходи для визначення оптимального способу видачі решти покупцеві: жадібний алгоритм та динамічне програмування.

 Опис алгоритмів:

Жадібний алгоритм

Функція `find_coins_greedy` реалізує жадібний алгоритм для видачі решти. Цей алгоритм вибирає монети з найбільшим номіналом, поки сума не буде сформована. Алгоритм працює швидко і ефективно для наборів номіналів, де жадібний підхід забезпечує оптимальне рішення.
Часова складність: O(n), де n — кількість монетних номіналів.
Продуктивність: Працює дуже швидко для обмеженого набору номіналів.
Оптимальність: Гарантує оптимальне рішення для певних наборів номіналів (наприклад, {1, 2, 5, 10, 25, 50}).

 Динамічне програмування

Функція `find_min_coins` реалізує підхід динамічного програмування для видачі решти. Цей алгоритм знаходить мінімальну кількість монет для формування заданої суми. Він завжди гарантує оптимальне рішення, хоча може бути повільнішим для великих сум.
Часова складність: O(n * amount), де n — кількість монетних номіналів, а amount — сума, яку потрібно видати.
Продуктивність: Може бути повільнішим за жадібний алгоритм для великих сум, але завжди гарантує оптимальне рішення.
Оптимальність: Гарантує оптимальне рішення для будь-якого набору монет.



Висновки
Жадібний алгоритм швидкий і ефективний для стандартних наборів монет (наприклад, номінали монет 1, 2, 5, 10, 25, 50). Він підходить для більшості практичних застосувань, де набір номіналів забезпечує оптимальне рішення.
Динамічне програмування підходить для випадків, коли набір номіналів не забезпечує оптимальне рішення жадібним методом. Хоча він може бути повільнішим, він гипадків, коли набір номіналів не забезпечує оптимальне рішення жадібним методом. Хоча він може бути повільнішим, він гарантує мінімальну кількість монет для будь-якого набору номіналіварантує мінімальну кількість монет для будь-якого набору номіналів.

Таким чином жадібний алгоритм є швидким і ефективним для стандартних наборів монет, тоді як алгоритм динамічного програмування підходить для випадків, коли жадібний алгоритм не може забезпечити оптимальне рішення.
